# TIL_220627

## #️⃣ 버블 정렬 알고리즘

### 1️⃣ 개요

만약 [4,3,1,2] 배열을 sort 메서드를 활용하여 정렬을 하면 [1,2,3,4]로 오름차순 정렬이 된다.

오늘은 버블 정렬 알고리즘을 이용하여 .sort() 메서드와 동일하게 배열의 오름차순 정렬이 가능한 함수를 만들어 보고자 한다.

<br/>
<br/>
### 2️⃣ 버블 정렬 알고리즘

버블 정렬 알고리즘이란  두 인접한 원소를 검사하여 정렬하는 방법으로 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이라고 한다. (출처 : [위키백과](https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC))

즉, 위의 예 처럼 [4,3,1,2]  이라는 배열이 주어질 경우,

1) 4와 3을 비교해서 4>3 이므로 4와 3의 위치를 바꿔서, ⇒ [3,4,1,2]

2) 4와 1을 비교해서 4>1 이므로 4와 1의 위치를 바꿔서, ⇒ [3,1,4,2]

3) 4와 2를 비교해서 4>2 이므로 4와 2의 위치를 바꿔서 , ⇒ [3,1,2,4]
<br/>
그리고 다시 처음부터 시작해서

4) 3과 1을 비교해서 3>1 이므로 3과 1의 위치를 바꿔서, ⇒ [1,3,2,4]

5) 3과 2를 비교해서 3>2 이므로 3과 2의 위치를 바꿔서, ⇒ [1,2,3,4]
<br/>
그리고 다시 처음부터 시작해

6) 1과 2를 비교해서 1<2 이므로 위치를 바꾸지 않고 ⇒ [1,2,3,4]

이와 같은 방식으로 정렬을 하는 것이다.
<br/>
<br/>
### 3️⃣ 버블 정렬 알고리즘을 활용하여 함수 구현

위의 방식을 봤을 때 전체적으로 단락을 나눈것 처럼 index 0부터 시작하는 반복이 배열 길이의 -1 만큼은 반복이 되며,

해당 반복 안에서, 첫번째 반복일 경우에는 다시 0번째와 1번째를 비교 → 1번째와 2번째를 비교 → 2번째와 3번째 비교 → 3번째와 4번째 비교하므로 총 배열의 길이의 -1만큼 비교를 하게 되고,

두번재 반복일 경우는 다시 0번째와 1번째를 비교 → 1번째와 2번째를 비교 → 2번째와 3번째를 비교 그리고 마지막 배열의 값은 이미 첫번째 반복으로 가장 큰 수가 위치하므로 더 이상 반복을 진행하지 않으므로 총 배열의 길이의 -2만큼 비교를 하게 된다.

이는 반복이 진행될수록 마지막 배열에는 가장 큰수가 이미 정렬이 되어 있으므로 확인할 인덱스가 하나씩 줄어든다는 것을 의미한다.

따라서 이를 코드로 구현하면 아래와 같다.

```jsx
const bubbleSort = (arr) => {
    for (let i=0; i<arr.length-1; i++) {
      for (let k=0; k<arr.length-1-i; k++) {
        if(arr[k] > arr[k+1]) {
          let temp = arr[k]; 
          arr[k] = arr[k+1]; 
          arr[k+1] = temp;
        }
      }
    }
    return arr;
};
```

이와 같은 코드를 구현하면 오름차순 정렬이 구현된다.
<br/>
<br/>
### 4️⃣ 함수 효율적으로 개선하기

하지만 우리는 첫번째 큰 반복문을 실행시킬때, 해당 반복문 안의 반복문에서 정렬이 이루어지지 않으면 

이미 해당 시점에서 오름차순 정렬이 완료된 배열이라는 것을 알 수 있다.

따라서 두번째 반복문에서 어떠한 변화도 없을 경우에는 더이상 첫번째 반복문을 계속 진행시킬 필요가 없다.

이를 구현하기 위해서 배열의 위치를 바꿔주기 위해서 만들었던 임시 변수인 temp를 첫번째 반복문에서 선언을 해주고, 

만약 두번째 반복문을 실행시키고 난 다음 temp에 어떠한 것도 할당이 되지 않을 경우에는 이미 오름차순 정렬이 완료된 것으로 간주하고 반복문을 종료시키면 된다.

해당 코드를 구현하면 아래와 같다.

```jsx
const bubbleSort = (arr) => {
    for (let i=0; i<arr.length-1; i++) {
      let temp;
      for (let k=0; k<arr.length-1-i; k++) {
        if(arr[k] > arr[k+1]) {
          temp = arr[k]; 
          arr[k] = arr[k+1]; 
          arr[k+1] = temp;
        }
      }
      if (!temp) {
        break
      }
    }
    return arr;
```